% Conclusion
\chapter{Conclusion}

Game engines are software applications with a great requirement for performance and control by the developer. One factor to reach that goals is the programming language used for the implementation. In this thesis the author implemented engine modules in C++ and Rust and compared them. Based on the execution times of several benchmark scenarios, the results showed that C++ generally performs better in most cases. But although C++ performed better, the Rust implementations and their performance did not yield bad results. Most of the time the measured times were about 25\% to 30\% percent slower than the C++ times, but Rust's new concepts force the developer to think about several assumptions made in the C++ modules.

With Rust being a rather infant language and by having it supported by a growing community it can be said, that it can be considered as a good tool for developing real-time and system-level applications. Most of the performance overhead introduced by Rust is due to some features that are currently missing. One of them being placement-new and therefore some concepts from C++ cannot be mapped directly to Rust. But while the performance is not at the exact level of C++, the general system performance was rather good. And beside that, Rust's compiler help a programmer a lot with eventual implementation errors, especially when working with low-level concepts or limits of certain types. Features such as explicit conversions of numeric types and utility functions for pointer arithmetic are helpful tools when implementing low-level systems.

Beside real-time solutions, the author sees great potential in Rust for becoming an established language for tools development. With Rust's ergonomic and error handling features, tool applications can benefit from having proper error handling without great effort. While implementing the benchmark tool \textit{SparkX}, the author appreciated the helpful compiler error messages as well as the pattern matching features.

However, C++ will most certainly stay the tool of choice for demanding applications in the future, but Rust has the potential to be a competitor in the field of engine design. The author will continue to examine Rust's viability and progress in that field. For this reason it is planned to extend the already developed parts of Spark and add further capabilities for rendering and multi-threading support. This future work shall serve as a proof-of-concept and a project to look at when the capabilities of Rust are discussed. 