% Custom MA template for Rust - Modular game engine
% !TEX encoding = UTF-8 Unicode

% FHTW document class for cooperate identity master thesises
\documentclass[MGS, Master, english]{twbook}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

% Define the standard for citations for this paper - IEEE or HARVARD
\newcommand{\FHTWCitationType}{IEEE} 
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{\usepackage{harvard}}{\usepackage{bibgerm}}

% Format code listings
\usepackage[final]{listings}
\lstset{captionpos=b, numberbychapter=false,caption=\lstname,frame=single, numbers=left, stepnumber=1, numbersep=2pt, xleftmargin=15pt, framexleftmargin=15pt, numberstyle=\tiny, tabsize=3, columns=fixed, basicstyle={\fontfamily{pcr}\selectfont\footnotesize}, keywordstyle=\bfseries, commentstyle={\color[gray]{0.33}\itshape}, stringstyle=\color[gray]{0.25}, breaklines, breakatwhitespace, breakautoindent}
\lstloadlanguages{[ANSI]C, C++, [gnu]make, gnuplot, Matlab}

% -----------------------------------------
% Format the list of code
\makeatletter
% Setzen der Bezeichnungen für das Quellcodeverzeichnis/Abkürzungsverzeichnis in Abhängigkeit von der eingestellten Sprache
\providecommand\listacroname{}
\@ifclasswith{twbook}{english}
{%
	\renewcommand\lstlistingname{Code}
	\renewcommand\lstlistlistingname{List of Code}
	\renewcommand\listacroname{List of Abbreviations}
}{%
	\renewcommand\lstlistingname{Quellcode}
	\renewcommand\lstlistlistingname{Quellcodeverzeichnis}
	\renewcommand\listacroname{Abkürzungsverzeichnis}
}
% Wenn die Option listof=entryprefix gewählt wurde, Definition des Entyprefixes für das Quellcodeverzeichnis. Definition des Macros listoflolentryname analog zu listoflofentryname und listoflotentryname der KOMA-Klasse
\@ifclasswith{scrbook}{listof=entryprefix}
{%
	\newcommand\listoflolentryname\lstlistingname
}{%
}
\makeatother
\newcommand{\listofcode}{\phantomsection\lstlistoflistings}

% Die nachfolgenden Pakete stellen sonst nicht benötigte Features zur Verfügung
\usepackage{blindtext}

% -----------------------------------------
%
% Einträge für Deckblatt, Kurzfassung, etc.
%
\title{Modular game engine in Rust - Comparing performance and memory usage of subsystems to C++}
\author{Lukas Vogl, BSc.}
\studentnumber{gs16m007}
\supervisor{Dipl.-Ing. Stefan Reinalter}
\secondsupervisor{Mag.rer.nat. Dr.techn. Eugen Jiresch}
\place{Wien}
% German abstract
\kurzfassung{
Modulare Spieleengines zeichnen sich dadurch aus, dass sie intern aus verschiedenen Subsystemen bestehen die unterschiedlichste Aufgaben abarbeiten. Beispielhafte Systeme sind unter anderem Speichermanagement, Rendering oder Physiksimulation. Die Gemeinsamkeit zwischen den Systemen, unabhägig davon wie hardwarenahe oder abstrakt diese sind, sind Aspekte wie Performance und Speicherverbrauch. Um möglichst viel Kontrolle über diese Bereiche zu haben entscheiden sich viele EntwicklerInnen für Systemprogrammiersprachen wie C++ als Entwicklungswerkzeug. Im Zuge dieser Arbeit wird der Autor die seit 2015 existierende Programmiersprache Rust verwenden um ausgewählte Subsysteme einer modularen Spieleengine zu implementieren. Ziel der Arbeit ist es zu untersuchen, ob Rust durch seine neuen Konzepte gängige Schwierigkeiten bei der C++ Entwicklung vermeiden und gleichzeitig eine gleichwertige Performance liefern kann. Dafür werden die in Rust implementierten Systeme zusätzlich in C++ implementiert und anschließend in verschiedenen Szenarien vermessen und verglichen. Aus den Ergebnissen wird evaluiert ob Rust als Programmiersprache für Spieleengines in Frage kommt. Zusätzlich werden die Implementierungsdetails der verschiedenen Sprachen und Systeme behandelt, wodruch aufgezeigt wird welche Unterschiede zwischen den beiden Sprachen bestehen.

}
\schlagworte{Rust, C++, Engine, Speichermanagement, Performance}
% English abstract
\outline{
Modular game engines are defined by the fact that they are composed of different subsystems working on many distinct tasks.
Exemplary systems are, inter alia, memory management, rendering or physics simulation. The similarity between the systems, regardless of how low-level or abstract they are, are performance and memory consumption. To gain control over these fields most programmers choose system programming languages such as C++ as development tool. In this thesis the the author chose the programming language Rust to implement selected subsystems of a modular game engine. Is it the goal of the thesis to investigate whether Rust can avoid common difficulties known from C++ due to its new concepts while maintaining C++ like performance. For this purpose the selected systems will also be implemented in C++. They are then surveyed in different scenarios and compared to each other. The results are evaluated to see whether it is worth considering using Rust as a language for game engine programming. Furthermore the implementation details ofthe different languages and systems are discussed whereby the differences between the two languages are outlined;
}
\keywords{Rust, C++, Engine, Memory management, performance}
\acknowledgements{\blindtext}

% -----------------------------------------
\begin{document}
	
%Festlegungen für den HARVARD-Zitierstandard
\ifthenelse{\equal{\FHTWCitationType}{HARVARD}}{
	\bibliographystyle{Harvard_FHTW_MR}%Zitierstandard FH Technikum Wien, Studiengang Mechatronik/Robotik, Version 1.2e
	\citationstyle{dcu}%Correct citation-style (Harvardand, ";" between citations, "," between author and year)
	\citationmode{abbr}%use "et al." with first citation
	\iflanguage{ngerman}{
		%Deutsch Neue Rechtschreibung
		\newcommand{\citepic}[1]{(Quelle: \protect\cite{#1})}%Zitat: Bild
		\newcommand{\citefig}[2]{(Quelle: \protect\cite{#1}, S. #2)}%Zitat: Bild aus Dokument
		\newcommand{\citefigm}[2]{(Quelle: modifiziert "ubernommen aus \protect\cite{#1}, S. #2)}%Zitat: modifiziertes Bild aus Dokument
		\newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
		\newcommand{\acessedthrough}{Verf{\"u}gbar unter:}%Für URL-Angabe
		\newcommand{\acessedthroughp}{Verf{\"u}gbar bei:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
		\newcommand{\acessedat}{Zugang am}%Für URL-Datum-Angabe
		\newcommand{\singlepage}{S.}%Für Seitenangabe (einzelne Seite)
		\newcommand{\multiplepages}{S.}%Für Seitenangabe (mehrere Seiten)
		\newcommand{\chapternr}{K.}%Für Kapitelangabe
		\renewcommand{\harvardand}{\&}%Harvardand in Zitaten
		\newcommand{\abstractonly}{ausschließlich Abstract}
		\newcommand{\edition}{. Auflage}%Angabe der Auflage
	}{
		\iflanguage{german}{
			%Deutsch
			\newcommand{\citepic}[1]{(Quelle: \protect\cite{#1})}%Zitat: Bild
			\newcommand{\citefig}[2]{(Quelle: \protect\cite{#1}, S. #2)}%Zitat: Bild aus Dokument
			\newcommand{\citefigm}[2]{(Quelle: modifiziert "ubernommen aus \protect\cite{#1}, S. #2)}%Zitat: modifiziertes Bild aus Dokument
			\newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
			\newcommand{\acessedthrough}{Verf{\"u}gbar unter:}%Für URL-Angabe
			\newcommand{\acessedthroughp}{Verf{\"u}gbar bei:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
			\newcommand{\acessedat}{Zugang am}%Für URL-Datum-Angabe
			\newcommand{\singlepage}{S.}%Für Seitenangabe (einzelne Seite)
			\newcommand{\multiplepages}{S.}%Für Seitenangabe (mehrere Seiten)
			\newcommand{\chapternr}{K.}%Für Kapitelangabe
			\renewcommand{\harvardand}{\&}%Harvardand in Zitaten
			\newcommand{\abstractonly}{ausschließlich Abstract}
			\newcommand{\edition}{. Auflage}%Angabe der Auflage
		}{
			%Englisch
			\newcommand{\citepic}[1]{(Source: \protect\cite{#1})}%Zitat: Bild
			\newcommand{\citefig}[2]{(Source: \protect\cite{#1}, p. #2)}%Zitat: Bild aus Dokument
			\newcommand{\citefigm}[2]{(Source: taken with modification from \protect\cite{#1}, p. #2)}%Zitat: modifiziertes Bild aus Dokument
			\newcommand{\citep}{\citeasnoun}%In-Line Zitiat entweder mit \citep{} oder \citeasnoun{}
			\newcommand{\acessedthrough}{Available at:}%Für URL-Angabe
			\newcommand{\acessedthroughp}{Available through:}%Für URL-Angabe (Geschützte Datenbank, Zugriff durch FH)
			\newcommand{\acessedat}{Accessed}%Für URL-Datum-Angabe
			\newcommand{\singlepage}{p.}%Für Seitenangabe (einzelne Seite)
			\newcommand{\multiplepages}{pp.}%Für Seitenangabe (mehrere Seiten)
			\newcommand{\chapternr}{Ch.}%Für Kapitelangabe
			\renewcommand{\harvardand}{\&}%Harvardand in Zitaten
			\newcommand{\abstractonly}{Abstract only}
			\newcommand{\edition}{~edition}%Edition -> note, that you have to write "edition = {2nd},"!
}}}

\maketitle

\chapter{Introduction}
Game engines are an essential part of the gaming industry. Todays state-of-the-art game engines have committed themselves to the goal of creating visually appealing games while providing reasonable performance. Achieving this requires the engine engineers to invest a great amount of time and know-how of underlying hardware. Many of these engines, choosing Unity and Unreal Engine 4 as example, are using C++ as underlying technology. C++ is the language of choice due to it's capabilities of managing memory manually without the limitations of a garbage collector. These capabilities are the foundation for high performance software and essential to game engines. But while the benefits of manual memory management are indisputable it also comes with common pitfalls. 

This thesis aims to examine whether the system programming language Rust can be used as a replacement for C++. Rust claims to avoid pitfalls made in C++ while maintaining similar performance. As a basis for discussion the author will implement selected engine subsystems: memory management, containers and an \ac{ECS}. All systems, except for the \ac{ECS} which already exists in Rust, are written in Rust and C++ to later measure and compare their performance in different scenarios. The results of the measurements shall then serve as the basis for the discussion if Rust can be considered as a viable language for game engine programming.

Chapter 2 will introduce the reader to the history and evolution of game engines. It will also outline state-of-the-art products and shortly describe them. Furthermore, it introduces important tools that tightly related to the underlying engine and the concept of an asset pipeline, concluding the chapter with a section presenting the theory and examples of selected engine subsystems.
The next chapter provides the reader with an overview of the Rust programming language. It describes the current state of Rust and creates a basic understanding of it by introducing the most important concepts and patterns. It will then compare common and well-known C++ problems and pitfalls with corresponding code in Rust. At the end the author outlines encountered difficulties that can occur when working with Rust. 
In chapter 4 the author talks about the implementation details of the implemented subsystems and where the differences between Rust and C++ are visible. The development process, architecture and project setup of the Spark engine (the implemented submodules will serve as a basis for this engine in future work) will be discussed. The performance measurement results and observed scenarios are then compared and discussed in chapter 5. Chapter 6 will then finish the thesis with the conclusion.


% Game engine arch
\chapter{Game engine architecture}

Game engines are tightly connected to the evolution of video games themselves. Where 50 years ago a game was build out of hardware the rapid development of a computer's processing power and storage capabilities changed the process of how games are made. Today a game runs on machines assembled from multiple cores, several \acp{GB} of \ac{RAM} and a powerful \ac{GPU}. But whether the target platform is a PC or a specialized gaming console every modern game has to fulfill certain constraints to be a viable product. This chapter will highlight some of the most important milestones in the history of video games and game engines. It will also give an overview of well-known products on the game engine market and will conclude with the description of selected submodules, the underlying building blocks of a game engine.

\section{Evolution of game engines}

When the first developers started to create video games, the term \textit{game engine} was non existent. At this time the software that ran the simulation a player experienced was tailored to the needs of a specific genre, hardware and game. It was then in the 1990s and with the rise of games like \textit{Doom (1993)} and \textit{Quake (1996)} that certain software was referred to as a \textit{game engine}. The mentioned games separated their technical backbones into different components, creating an architecture that distinguishes between core software modules and game specific entities such as art assets, levels and the general rules of the game. Due to the well-designed architecture and separations the effort to create a new game, where the general concept is the same, was reduced from writing every system and piece of code to creating new art and only tweak and configure the software of previous games. This was also the birth of the \textit{modding} community, where individuals and also studios modify existing games or engine software to create new content or whole games.

From that time on the developers created their games with modding and future extension in mind. Smaller studios started to license the parts of the engine software they could not afford to create by themselves, be it money, time or man power. With the concept of licensing studios, that created the extensible and reusable software packages, created another source of income. But while the goal of an extensible and reusable software collection is a desirable one, the line between a game and an engine is often softer than desired. Because of the nature of games and their specific genre rules it is hard, if not even impossible, to develop a generic engine that can serve as a template for every game. It became the responsibility of the engine developer to find the balance between general-purpose functionality and game or platform tailored optimizations. This trade-off has to be made because the developer can only assume how the software will be used. And so a game engine developed and optimized for rendering \acp{FPS} will probably not run a \ac{RTS} game with maximum performance due to the different rule sets and features both genres require.

Empowered by the wish of creating games that can be modded and licensed bigger studios started to create commercial engines. \textit{Id Software}, the company that created \textit{Doom} and the \textit{Quake} trilogy, opened up the field with their \ac{FPS} engines in the early 1990s. \textit{Id Software} was then followed by \textit{Epic Games, Inc.}, the creator of the Unreal Engine, which served as the basis for their well-known game \textit{Unreal} and later the \textit{Unreal Tournament} series. The current version, the Unreal Engine 4, is one of the most popular game engines of our time and will be described in the next section. Other game engines started that time and which should not be left unmentioned are \textit{CryENGINE} (Crytech), \textit{Source Engine} (Valve), \textit{Frostbite} (DICE) and \textit{Unity}.

A long time many, if not all, of the named engines followed a model of selling licenses to developers for accessing the engine and the source code. But it was around 2009 to 2015 that big engine developers including Unity and Epic Games, decided to rework their business model and let developers use their software for free. The license terms often include a revenue share if the game should be successful but the basic usage of the engines is free most of the time. Although this certainly had a huge impact on smaller engines and teams that cannot compete with the teams working at Epic or Unity, this decision lowered the entrance barrier for ongoing game developers and students and can be seen as one of the biggest milestones in the modern history of game engines.

Speaking of Unity and Epic, the next section will describe modern game engines in the market, how they work and what they are used for. In contrast to Unity and Unreal Engine 4, two smaller engines will be described to show the difference between the approaches and why the flexibility of smaller engines and teams can also be an advantage over big software projects.


\section{Modern commercial game engines}

As described in the previous section game engines evolved from extensible game or genre tailored software to standalone viable products used to create different games. The market is actually dominated by two big engines, Unity and Unreal Engine 4, whereas the rest is separated between custom in-house and several medium to small engines and open source projects. The author is going to describe the features and license models of the two big solutions as well as of two smaller but more flexible ones.

\subsection{Unreal Engine 4}
\blindtext
\subsection{Unity}
\blindtext
\subsection{Molecular}
\blindtext
\subsection{Tombstone}
\blindtext
\section{Rust game engines}
\blindtext
\subsection{Piston}
\blindtext
\subsection{Amethyst}
\blindtext
\section{Tools and asset pipeline}
\blindtext
\subsection{Editor}
\blindtext
\subsection{Asset pipeline}
\blindtext
\section{Engine subsystems overview}
\blindtext
\subsection{Memory Management}
\blindtext
\subsubsection{Custom Allocators}
\blindtext
\subsection{Job System}
\blindtext
\subsection{Rendering}
\blindtext
\subsection{Entity Component System}
\blindtext
\subsection{Scripting}
\blindtext
% Rust
\chapter{Rust}
\blindtext
\section{Current state}
\blindtext
\section{Rust ecosystem}
\blindtext
\section{Concepts}
\blindtext
\subsection{Borrow checker}
\blindtext
\subsection{Traits}
\blindtext
\subsection{Hygienic macros}
\blindtext
\section{Pitfalls}
\blindtext
% Implementation
\chapter{Subsystem implementation}
\blindtext
\section{Spark engine architecture}
\blindtext
\section{Development environment}
\blindtext
\section{Rendering framework}
\blindtext
\section{Memory Management}
\blindtext
\subsection{API}
\blindtext
\subsection{C++ implementation}
\blindtext
\subsection{Rust implementation}
\blindtext
\section{Containers}
\blindtext
\subsection{API}
\blindtext
\subsection{C++ implementation}
\blindtext
\subsection{Rust implementation}
\blindtext
\section{Entity Component System}
\blindtext
\subsection{API}
\blindtext
\subsection{C++ implementation}
\blindtext
\subsection{Rust implementation}
\blindtext
% Result evaluation
\chapter{Measures \& Comparisons}
\blindtext
\section{Environment}
\blindtext
\section{Testcases}
\blindtext
\section{C++ performance}
\blindtext
\subsection{Memory Management}
\blindtext
\subsection{Container}
\blindtext
\subsection{Entity Component System}
\blindtext
\section{Rust performance}
\blindtext
\subsection{Memory Management}
\blindtext
\subsection{Container}
\blindtext
\subsection{Entity Component System}
\blindtext
\section{Comparison}
\blindtext
% Conclusion
\chapter{Conclusion}

%
% Hier beginnen die Verzeichnisse.
%
\clearpage
\nocite{GEA_2}
\nocite{C_Lan}
\nocite{ProRus}
\nocite{GEG_3}
\nocite{Portisch17}
\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,Literatur}
\clearpage
% Das Abbildungsverzeichnis
\listoffigures
\clearpage

% Das Tabellenverzeichnis
\listoftables
\clearpage

% Das Quellcodeverzeichnis
\listofcode
\clearpage

\phantomsection
\addcontentsline{toc}{chapter}{\listacroname}
\chapter*{\listacroname}
\begin{acronym}[]
	\acro{ECS}{Entity Component System}
	\acro{GB}{Gigabyte}
	\acro{RAM}{Random-Access-Memory}
	\acro{GPU}{graphics processing unit}
	\acro{FPS}{first person shooter}
	\acro{RTS}{real-time strategy}
\end{acronym}

\end{document}